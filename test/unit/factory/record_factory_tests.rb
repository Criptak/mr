require 'assert'
require 'mr/factory/record_factory'

require 'mr/fake_record'
require 'mr/record'

class MR::Factory::RecordFactory

  class UnitTests < Assert::Context
    desc "MR::Factory::RecordFactory"
    setup do
      @factory_class = MR::Factory::RecordFactory
    end
    subject{ @factory_class }

    should "include the apply args mixin" do
      assert_includes MR::Factory::ApplyArgs, subject
    end

  end

  class InstanceTests < UnitTests
    setup do
      @record_class = TestFakeRecord
      @factory = @factory_class.new(@record_class)
    end
    subject{ @factory }

    should have_imeths :instance, :saved_instance, :instance_stack
    should have_imeths :default_args

    should "allow reading/writing default args using `default_args`" do
      assert_equal({}, subject.default_args)
      subject.default_args(:name => 'test')
      assert_equal({ 'name' => 'test' }, subject.default_args)
    end

    should "yield itself when a block is passed to `new`" do
      yielded = nil
      factory = @factory_class.new(@record_class){ yielded = self }
      assert_equal factory, yielded
    end

  end

  class InstanceMethodTests < InstanceTests
    desc "instance"

    should "return an instance of the record" do
      record = subject.instance
      assert_instance_of @record_class, record
    end

    should "default columns for the record" do
      record = subject.instance
      assert_instance_of String, record.name
    end

    should "apply passed args to the record" do
      record = subject.instance(:name => 'test')
      assert_equal 'test', record.name
    end

    should "apply default args to the record" do
      subject.default_args(:name => 'test')
      record = subject.instance
      assert_equal 'test', record.name
    end

    should "apply passed args over default args to the record" do
      subject.default_args(:name => 'first')
      record = subject.instance(:name => 'second')
      assert_equal 'second', record.name
    end

    should "yield the record to a passed block" do
      yielded = nil
      record = subject.instance{ |r| yielded = r }
      assert_same record, yielded
    end

  end

  class SavedInstanceMethodTests < InstanceTests
    desc "saved_instance"

    should "build an instance of the record and save it" do
      record = subject.instance
      Assert.stub(subject, :instance){ record }
      assert_same record, subject.saved_instance
      assert_false subject.saved_instance.new_record?
    end

    should "reset the fake record's save called flag" do
      record = subject.saved_instance
      assert_false record.save_called
    end

  end

  class InstanceStackTests < InstanceTests
    desc "instance_stack"
    setup do
      @record = @record_class.new.tap(&:save!)
      Assert.stub(@factory, :instance).with(nil){ @record }

      @record_stack = 'a-record-stack'
      Assert.stub(MR::Factory::RecordStack, :new).with(@record){ @record_stack }

      @record_with_args = @record_class.new.tap(&:save!)
      Assert.stub(@factory, :instance).with(:name => 'test'){ @record_with_args }

      @args_record_stack = 'a-record-stack-with-args'
      Assert.stub(MR::Factory::RecordStack, :new).with(@record_with_args) do
        @args_record_stack
      end
    end

    should "return a record stack for an instance generated by itself" do
      assert_equal @record_stack, subject.instance_stack
    end

    should "pass args when generating an instance for the record stack" do
      assert_equal @args_record_stack, subject.instance_stack(:name => 'test')
    end

    should "yield the stack to a passed block" do
      yielded = nil
      stack = subject.instance_stack{ |s| yielded = s }
      assert_same stack, yielded
    end

  end

  class DupArgsTests < InstanceTests
    desc "building multiple models"
    setup do
      @factory = @factory_class.new(@record_class)
      @factory.default_args(:user => { :area => { :name => 'Test' } })
    end

    should "not alter the defaults hash when applying args" do
      assert_equal 'Test', @factory.instance.user.area.name
      assert_equal 'Test', @factory.instance.user.area.name
    end

  end

  class TestFakeRecord
    include MR::FakeRecord

    attribute :name,    :string
    attribute :area_id, :integer
    attribute :user_id, :integer

    belongs_to :area, 'MR::Factory::RecordFactory::TestFakeRecord'
    belongs_to :user, 'MR::Factory::RecordFactory::TestFakeRecord'

  end

end
