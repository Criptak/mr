require 'assert'
require 'mr/factory/model_factory'

require 'mr/fake_record'
require 'mr/test_helpers'
require 'mr/model'
require 'mr/record'

class MR::Factory::ModelFactory

  class UnitTests < Assert::Context
    include MR::TestHelpers

    desc "MR::Factory::ModelFactory"
    setup do
      @factory_class = MR::Factory::ModelFactory
    end
    subject{ @factory_class }

    should "include the apply args mixin" do
      assert_includes MR::Factory::ApplyArgs, subject
    end

  end

  class InstanceTests < UnitTests
    setup do
      @model_class  = TestModel
      @record_class = TestFakeRecord

      @record_factory = MR::Factory::RecordFactory.new(@record_class)
      MR::Factory::RecordFactory.stubs(:new).tap do |s|
        s.with(@record_class)
        s.returns(@record_factory)
      end

      @factory = @factory_class.new(@model_class, @record_class)
    end
    teardown do
      MR::Factory::RecordFactory.unstub(:new)
    end
    subject{ @factory }

    should have_imeths :instance, :saved_instance, :instance_stack
    should have_imeths :default_args

    should "allow reading/writing default args using `default_args`" do
      assert_equal({}, subject.default_args)
      subject.default_args(:name => 'test')
      assert_equal({ 'name' => 'test' }, subject.default_args)
    end

    should "yield itself when a block is passed to `new`" do
      yielded = nil
      factory = @factory_class.new(@model_class, @record_class){ yielded = self }
      assert_equal factory, yielded
    end

  end

  class InstanceMethodTests < InstanceTests
    desc "instance"
    setup do
      @record = @record_class.new
      @record_factory.stubs(:instance).returns(@record)
    end

    should "return an instance of the model" do
      model = subject.instance
      assert_instance_of @model_class, model
    end

    should "build a record instance for the model using a record factory" do
      model = subject.instance
      assert_same @record, model.record
    end

    should "apply passed args to the model" do
      model = subject.instance(:name => 'test')
      assert_equal 'test', model.name
    end

    should "apply default args to the model" do
      subject.default_args(:name => 'test')
      model = subject.instance
      assert_equal 'test', model.name
    end

    should "apply passed args over default args to the model" do
      subject.default_args(:name => 'first')
      model = subject.instance(:name => 'second')
      assert_equal 'second', model.name
    end

    should "yield the model to a passed block" do
      yielded = nil
      model = subject.instance{ |m| yielded = m }
      assert_same model, yielded
    end

  end

  class SavedInstanceMethodTests < InstanceTests
    desc "saved_instance"

    should "build an instance of the model and save it" do
      model = subject.instance
      subject.stubs(:instance).returns(model)
      assert_same model, subject.saved_instance
      assert_false subject.saved_instance.new?
    end

    should "reset the fake model's save called flag" do
      model = subject.saved_instance
      assert_not_model_saved model
    end

  end

  class InstanceStackTests < InstanceTests
    desc "instance_stack"
    setup do
      @model = @model_class.new.tap(&:save)
      @factory.stubs(:instance).with(nil).returns(@model)

      @model_stack = 'a-model-stack'
      MR::Factory::ModelStack.stubs(:new).tap do |s|
        s.with(@model)
        s.returns(@model_stack)
      end

      @model_with_args = @model_class.new.tap(&:save)
      @factory.stubs(:instance).with(:name => 'test').returns(@model_with_args)

      @args_model_stack = 'a-model-stack-with-args'
      MR::Factory::ModelStack.stubs(:new).tap do |s|
        s.with(@model_with_args)
        s.returns(@args_model_stack)
      end
    end
    teardown do
      MR::Factory::ModelStack.unstub(:new)
    end

    should "return a model stack for an instance generated by itself" do
      assert_equal @model_stack, subject.instance_stack
    end

    should "pass args when generating an instance for the model stack" do
      assert_equal @args_model_stack, subject.instance_stack(:name => 'test')
    end

    should "yield the stack to a passed block" do
      yielded = nil
      stack = subject.instance_stack{ |s| yielded = s }
      assert_same stack, yielded
    end

  end

  class DupArgsTests < InstanceTests
    desc "building multiple models"
    setup do
      @factory = @factory_class.new(@model_class, @record_class)
      @factory.default_args(:user => { :area => { :name => 'Test' } })
    end

    should "not alter the defaults hash when applying args" do
      assert_equal 'Test', @factory.instance.user.area.name
      assert_equal 'Test', @factory.instance.user.area.name
    end

  end

  class TestFakeRecord
    include MR::FakeRecord

    attribute :name,    :string
    attribute :area_id, :integer
    attribute :user_id, :integer

    belongs_to :area, 'MR::Factory::ModelFactory::TestFakeRecord'
    belongs_to :user, 'MR::Factory::ModelFactory::TestFakeRecord'

  end

  class TestModel
    include MR::Model
    record_class TestFakeRecord

    field_accessor :name

    belongs_to :area
    belongs_to :user

    public :record

  end

end
